---
title: 20250116
description: 자바 스레드 기초
author: codongmin
date: 2025-01-16
tags: ["java", "thread"]
---





# Thread 

스레드란 프로그램 실행의 흐름 단위를 의미한다. 

프로세스는 실행되는 프로그램의 인스턴스로 독립된 메모리 공간을 부여받아 실행되고, 스레드는 프로세스 내부에서 자원을 공유하며 실행된다는 차이점이 존재한다. 

- 프로그램이 실행될 때는 최소 1개의 스레드를 가지고 있다. 프로그램의 시작 진입점인 `main()`메서드에서 시작되는 스레드를 메인스레드라 부른다.
- 메인스레드에서 필요하다면 추가적인 스레드를 생성할 수 있다. 



하나의 프로세스 안에는 여러 스레드가 존재할 수 있다. 이를 통해서 여러 작업들(실행 흐름)을 동시에 수행하여 성능을 향상시킬 수 있다. 프로세스 내부에서 자원을 공유하기 때문에 시스템 자원을 효율적으로 사용할 수도 있다. 

- 하나의 작업을 여러 프로세스로 처리하는 경우 스레드를 사용하는 것보다 많은 비용들을 지불해야한다. 프로세스는 일반적으로 개별적인 메모리 공간을 할당받기 때문에 메모리 공간을 위한 비용이 높고, 독립된 공간을 사용하기 때문에 서로 자원을 공유하는 것이 스레드보다 어렵다. 프로세스끼리 데이터를 공유하려면 프로세스간 통신을 위한 IPC 기법들을 사용해야하는데, 이는 같은 프로세스 내에서 스레드들 끼리 통신하는 비용보다 큼. 
- 



## Java에서 Thread를 생성하는 방법

자바에서는 Thread를 생성하는 방빕이 크게 2가지가 존재한다. 

1. Runnable 인터페이스를 구현한 구현객체를 Thread 생성자로 넘겨주는 방법
2. Thread 클래스를 직접 상속받는 방법



사실 Thread 클래스가 Runnable 인터페이스를 구현하고 있기 때문에 둘 다 Runnable 인터페이스의 추상메소드를 구현하는 것은 동일하다. Runnable 인터페이스는 단 하나의 추상메소드를 가지고 있다. `run()` 메소드인데, 스레드가 구체적으로 처리해야할 작업을 정의하는 메소드이다. 스레드가 실행될때는 이 run() 메소드를 호출하며, 이후 run() 메소드에 정의해둔 코드들이 실행된다. 일종의 스레드의 실행 진입점이다. 

Runnable 인터페이스와 Thread 클래스는 `java.lang` 패키지에 존재하므로 별도로 import 할 필요는 없다.



두 방식을 비교하면 다음과 같다. 



### Runnable 인터페이스 구현

```java
class RunnableSample implements Runnable {
		@Override
		public void run(){
				// 수행 작업
		}
}

--- 
public static void main(String[] args) {
  Runnable task = new RunnableSample();
  new Thread(task).start();
}
```

Runnable 인터페이스의 `run()`  추상 메소드를 구현하기만 하면 된다. 이렇게 Runnable을 구현한 구현객체는 스레드가 처리해야할 작업 클래스로서 사용할 수 있다. 별도의 작업 내용을 구현 객체로 분리해냈기 때문에,  스레드를 생성할때 생성자로 작업 객체(Runnable을 구현한)를 넘겨주기만한다.

Runnable을 구현한 task 객체는 heap 영역에 존재하기 때문에 다른 스레드들도 해당 객체를 참조해서 스레드를 실행할 수 있다. 작업과 실행의 주체를 분리하므로써 작업 코드를 서로 공유해서 사용할 수 있게된다. 이것이 Runnable 인터페이스를 구현하는 방식의 장점이다. 작업 코드를 재사용할 수 있게 된다. 

이렇게 되면 작업 객체만 따로 관리할 수 있게 되기 때문에 유지보수가 보다 쉬워지며, 코드의 재사용성도 늘어난다. 

뿐만 아니라 만일 RunnableSample 클래스가 다른 클래스를 확장해야한다면, Runnable 인터페이스를 구현하는 방식이 적합하다. 왜냐하면 자바의 경우 다중 상속이 불가능하기 때문에 Thread 클래스를 직접 상속받는 것이 불가능해진다. 보다 유연한 구성을 만들 수 있는 장점이 존재한다. 



### Thread 클래스 상속 

```java
class ThreadSample extends Thread {
  @Override
  public void run() {
    // 수행 작업
  }
}

public static void main(String[] args) {
	ThreadSample thread = new ThreadSample();
  thread.start();
}
```

Thread 클래스를 상속받아 구현하는 방법은 사용방식이 비교적 간단하다. 객체를 생성 후 바로 실행할 수 있다. Thread 클래스를 상속받았기 때문에 가능하다. 만일 스레드가될 클래스가 다른 클래스를 상속받아야한다면 Thread 클래스를 다중 상속할 수 없다. Runnable 인터페이스를 구현해서 생성하는 방법보다는 유연성이 떨어지고 Thread 클래스와 강하게 결합된다는 특징이 있다.

Thread 클래스를 직접 상속받는 경우에는 몇가지 주의사항이 있다. 반드시 `run()` 메서드 시그니처를 잘 확인해서 오버라이드해야한다. 올바르지 않은 다른 메소드를 작성할 경우 그냥 일반 메서드를 작성하는 것과 다를바없다. 

별도의 start() 메서드를 재정의하지 않도록 주의해야한다. start() 는 새로운 스레드를 생성하고 내부적으로 run() 메소드를 호출하는데 이때 start() 메소드에서 예기치 못한 멀티스레딩 동작을 깨뜨릴 수 있으니 주의해야한다. 

적절하게 상황에 맞게 구현하는 방법이 필요하다. 



# Synchronized






















---
title: 20250206
description: GC 객체 판단 기준, 문자열 상수 풀
author: codongmin
date: 2025-02-06
tags: ["jvm", "gc"]


---



# JVM에서 GC 대상 객체를 판단하는 기준

GC는 메모리 관리 방법 중 하나이며, JVM 런타임 메모리 영역 중 하나인 힙 영역에서 동적으로 할당했던 메모리 중 더 이상 사용하지 않는 객체를 주기적으로 제거해 메모리를 회수하는 것을 의미한다. GC는 특정 객체가 현재 사용중인지 아닌지를 판단하는 기준으로 **참조 도달 가능성 분석**을 사용한다. 특정 객체에 대한 유효한 참조가 존재하면 도달할 수 있는 상태이고, 유효한 참조가 존재하지 않는 경우 도달할 수 없는 상태로 간주함. 도달할 수 없는 상태의 객체를 가비지로 간주해 GC를 수행함. 한  객체는 여러 객체를 참조할 수 있고 참조된 다른 객체들도 마찬가지로 또 다른 객체들을 참조할 수 있으므로 객체들을 참조 사슬을 이룸.

힙 영역에 존재하는 객체에 대한 참조는 4가지가 존재함.

1. 힙 내부 객체간 참조
2. 메서드 실행시 사용하는 스택 영역의 지역 변수 혹은 매개변수에 의한 참조
3. JNI에 의해 생성된 객체에 대한 참조
4. 메서드 영역(static)의 정적 변수에 의한 참조.

유효한 참조 여부를 파악하려면 항상 유효한 최초 참조가 있어야 하는데 이를 객체참조의 루트객체 라고 함. 이중에 1번을 제외한 나머지 케이스가 루트 객체가 될 수 있음. 루트 객체는 참조 도달 가능성 분석을 위한 제일 첫 시작점으로 여겨짐. 루트 객체로부터 시작한 참조 사슬에 속한 객체들은 도달할 수 있으면 현재 사용중인 객체로 여겨지고, 이에 속하지 않는 객체들은 도달하기 어렵기 때문에, 사용되지 않으므로 GC의 메모리 회수 대상이 됨.



# 문자열 상수 풀 

Java에서 문자열 리터럴을 저장하는 독립된 영역을 “String Constant Pool” 또는 “String Pool” 이라고 부름.

JVM의 Perm/metaspace 영역에 존재하고, 일반적으로 GC의 대상이 되지는 않음. String은 불변객체이기 때문에, 문자열의 생성 시 String Constant Pool에 저장된 리터럴을 재사용할 수 있음.

<aside>

일반적으로 String constant pool은 gc가 되지 않지만, 문자열 참조 대상이 없는 경우 선택적으로 GC대상이 되기도 함.

</aside>

리터럴이란 소스코드 내 프로그래머에 의해 직접 작성된, 값이 고정된 데이터를 의미함. 실행중 변하지 않는 상수로 취급함. 예를 들어 “Hello”로 선언된 문자열이 문자열 상수 풀 저장 공간에 저장되며, 동적으로 생성된 문자열은 저장되지 않음. 한번 저장된 문자열은 소스 코드 내에서 동일한 문자열에 대해 재사용해 메모리를 절약함.

```java
String s1 = "Hello";
String s2 = "Hello";
// s1 == s1 true
```

동일한 문자열 값이 이미 존재하면 새로 객체를 생성하지 않고 기존 객체의 참조를 반환하는 과정을 **인터닝**이라고 부름. 만약 new 연산자를 사용해 문자열을 생성하면 강제로 힙영역에 새로운 객체가 만들어지는데 이 경우 상수 풀과 새롭게 만들어진 객체는 문자열 내용이 같더라도 비교시 서로 다른 값을 가짐.

소스코드에 리터럴 형태로 작성된 문자열은 컴파일 시 컴파일러에 의해 문자열 상수 풀 저장 대상으로 표시함. 표시하는 방법은 클래스 파일의 메타데이터중 상수풀(”CONSTANT_String”)타입으로 저장되면 런타임시 스캔대상이 됨.

이렇게 문자열 상수 풀을 사용하는 이유는 메모리 사용의 효율화. 문자열이 불변이라는 특징 덕분에 여러 객체에서 안전하게 공유하여 사용할 수 있음.

```java
String str = "Hello"; // String constant pool 에 저장됨.
String str2 = new String("Hello") // Heap 영역에 할당됨.

// str == str2 false
```

new 연산자를 사용하여 문자열을 생성할 경우 이 문자열을 Heap 영역에 별도 저장되기 때문에 문자열 상수풀로 최적화할 가능성이 없음. 최대한 리터럴 문자열을 사용하여 만드는 것이 좋음.

풀은 필요한 것을 담아두고 필요할때 꺼내사용한다. 재사용한다는 의미를 갖는 개념이 많음.
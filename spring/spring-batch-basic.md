---
title: 여러 작업을 한 번에 처리해야 한다면? 배치와 스프링 배치 이해
description: 
author: codongmin
date: 2025-02-01T21:34:00
categories:
  - 자바
tags: 
image:
  path: /assets/img/thumbnail/.png
  lqip: 
  alt: 이미지 설명
---


## 들어가며

최근 진행중인 사이드 프로젝트에서 배치 작업 기능을 구현해야하는 일이 있었고, 이를 구현하기 위해 조사하고 적용했던 내용들을 정리해봤습니다. 현재 진행중인 프로젝트는 크게 2개의 시스템으로 구성되어 있고 이 중 배치 작업을 필요로 했던 서비스는 추천 시스템입니다. 추천 시스템은 피드 시스템으로부터 유저의 관심 정보를 요청으로 받아 유저가 관심있어 할 만한 개인화된 피드 리스트를 반환해주는 역할을 담당하고 있습니다. 

먼저 현재 구현중인 추천 시스템은 유저와 비슷한 관심사를 가진 유저들이 좋아하는 피드들을 추천해주는 일종의 그룹기반 협업 필터링 방식을 채택하고 있습니다. 예를 들면, 내가 속한 직군의 사람들이 좋아하는 피드들을 선별하고 추천해주는 방식입니다. 이 방식은 과거 사용자의 행동 데이터와 데이터 중심의 추천방식으로 알고리즘이 직관적이고, 아이템의 도메인적인 지식이 필요하지 않다는 장점이 있습니다. 하지만 이 방식은 사용자 수와 사용자가 생성하는 게시글 수가 증가할수록 추천 피드를 선별하는 데 시간이 많이 소요될 수 있다는 단점이 있습니다.

현재 구조는 유저가 '나의 피드' 보기 API를 통해 피드 시스템으로 요청을 보내면, 추천 시스템이 이를 넘겨받아 추천 연산을 수행한 후 응답하는 흐름입니다. 시스템 규모가 커질수록 추천 연산 시간이 점차 늘어나면 추천 시스템의 응답속도도  자연스레 느려질 수 밖에 없습니다. 추천 시스템의 응답 지연은 이를 호출하는 피드 시스템에도 영향을 줄 것이고 결국 전체 서비스의 응답 속도 저하와 사용자의 경험 저하로 이어지게 될 가능성이 높습니다. 따라서 시스템의 규모가 커지더라도, 추천 기능은 일정한 응답속도를 보장하는 것이 필요했습니다.

이를 해결하기 위해 추천 시스템 내 저장되어 있는 추천에 필요한 피쳐 정보들을 일정 주기마다 미리 계산하여 캐싱해놓는 구조를 설계했습니다. 이 방식이라면 시스템 규모가 커져도 안정적인 응답 속도를 유지할 수 있을 것으로 기대했습니다.

이러한 배경에서, 피처 정보를 주기적으로 미리 계산하는 작업을 배치로 처리하기로 결정했습니다.  
그래서 이번 글에서는 배치가 무엇인지 간단히 살펴보고, 프로젝트에 적용한 Spring Batch의 구조에 대해 다뤄보려 합니다.

(*현재 프로젝트에서는 추천 알고리즘보다 백엔드 구조 설계에 중점을 두고 구현하는 데 집중했습니다. 추천과 관련해 잘못된 부분이나 오해가 있다면 언제든지 알려주시면 감사하겠습니다.)

## 배치란? 

배치는 특정 시점에 여러 작업을 일정한 단위로 묶어 한꺼번에 처리하는 방식을 의미합니다. 배치 프로그램은 정해진 시간에 일괄적으로 작업을 처리하는 프로그램을 말한다. 실시간으로 작업을 처리하는 것이 아닌, 정해진 시간에 몰아서 처리하는 특성을 갖는다. 

서비스를 운영하는 관점에서는 요청에 따라 지금 당장 처리될 필요는 없지만, 주기적으로 처리해주어야하는 일들이 배치성 작업에 속한다. 주로 필요한 데이터를 모아서 한꺼번에 처리해야하거나, 지연처리가 필요할 때, 시간이 오래 걸리거나 대량의 데이터를 처리해야하는 상황들이 있다. 덕분에 자원을 효율적으로 사용할 수 있다는 장점도 존재한다. 

예를 들면 월말에 기존에 발생했던 내역들을 종합해서 월별 거래 명세서를 만든다거나 매일 자정에 사용자 포인트를 정산한다거나, 누락된 데이터들을 주기적으로 검증하거나 보증해야하는 경우가 예시들이 될 수 있다.


### 특징 

데이터를 처리하는 방식을 실시간 처리와 배치처리로 나누어 비교해보면서 배치 처리의 특성을 알아보겠습니다. 

배치처리 
- 특정 시점에 데이터를 몰아서 처리하는 방식 
- 대량의 데이터에 일관된 작업을 수행할때, 
실시간 처리 
- 데이터 발생 즉시 처리하는 방식
- 사용자의 응답에 즉각적으로 반응해야할때, (실시간성 정보를 제공해야할 때)
- 비용이 많이 듦

주로 일정 시간동안 처리해야할 데이터를 수집하고, 이를 처리하고, 처리한 결과를 핸들링하는 구조로 동작한다. 
(그림)

처리된 결과를 바로 확인하지 않기 때문에 비동기적으로 처리한다는 특징도 가지고 있습니다.


- 효율적으로 자원 사용이 가능, 비용 절감(필요할때만 서버 가동하기 때문에.)
- 실시간으로 동작할 경우 성능저하 발생을 고려해야하지만, 배치 처리는 성능에 미치는 영향이 보다 적음. (시간 대를 지정할 수 있음.) 만약 피크타임때 이를 실시간으로 처리한다면, 요청을 처리하는 데 사용할 리소스를 배치처리할때 사용하기 때문에 전체적인 성능저하가 발생할 수도 있음. 
- 실시간 응답이 필요한 경우에는 배처로 처리해서는 안됨. 즉각적인 피드백을 줘야하는 경우. 
- 배치 작업을 스케줄링하고, 관리하는게 복잡할 수 있음. 충돌발생 가능성 존재. 
- 데이터의 일관성을 보장할 수 있음. 

## 배치 예시 

### 서비스 분야에서의 배치 처리  

1. 메시지, 이메일, 푸시 등을 발송할 때, 
2. 데이터를 마이그레이션할 때, 
3. 실패한 트랜잭션을 재처리할 때, 
4. 쿠폰, 포인트 등이 만료되었을 때 소진시키는 처리를 할 때, 
5. 월말 또는 월초에 특정 데이터를 생성할 때, 월별 거래 명세서

### 데이터 분야에서의 배치 처리 

1. 각 서비스의 데이터를 데이터 웨어하우스에 저장할 때, (ETL, Extract-Transform-Load)
2. 아마존에서 연관 상품을 추천하는 데이터 모델을 만들 때, 
3. 유저의 리텐션 등 마케팅에 참고할 데이터 지표를 집계할 때


## Spring Batch란 

대규모 데이터를 일괄되게 처리할 수 있도록 도와주는 자바 기반의 배치 프레임워크입니다.
견고한 배치 애플리케이션 개발이 가능하도록 다양한 기능을 가지고 있다.

스프링 배치 프레임워크는 스프링 프레임워크의 일부로 스프링의 트랜잭션 관리 & 데이터 엑세스 기술을 확장해 배치 전용 기술들을 제공한다는 점이 장점입니다. 또한 스프링의 서비스에서 작성했던 코드들을 재활용해서 배치처리에 사용이 가능하기 때문에 기존 스프링 애플리케이션과의 뛰어난 통합성을 제공한다는 특징을 갖습니다. 기존 모듈을 스프링 배치에서 Import 해서 사용할 수도 있다. 덕분에 생산성 있게 사용이 가능하다.

대용량 데이터 배치처리에 필요한 다양한 기능들을 제공한다. 
- 로깅과 추적, 트랜잭션 관리, 작업 처리 통계.
- 청크 기반 작업 처리.
- 실패 복구, 재시작/건너뛰기 가능.
- 스케줄링 연동 용이.
- 다양한 입출력 (Reader, Writer) 지원.
- 멀티 코어, 또는 멀티 서버에서 처리 분산 기능.


스프링 배치 2.0에서부터는 성능 개선과 병렬 처리가 가능해졌고, 3.0부터는 자바 배치처리 표준 지원 -> 표준화된 배치처리 api.


## 배치 구성요소, 아키텍처 
스프링 배치는 크게 다음과 같은 구성 요소들로 이루어져있다.

![batch-diagram](https://docs.spring.io/spring-batch/reference/_images/spring-batch-reference-model.png)


먼저 배치처리할 작업을 Job이라고 부른다. 이 Job을 실행시키는 역할을 하는 컴포넌트가 JobLauncher이다. 일종의 트리거라고 볼 수 있다. 

Step은 Job을 처리하기 위한 단계를 의미한다. 작업을 처리하기 위한 단계는 여러 단계가 존재할 수 있으므로 1:N 관계를 갖는다. 하나의 Job이 여러 Step을 가질 수 있음을 의미한다.

JobRepository 는 Job, Job 실행 이력, 파라미터, Step 정보 등을 저장한다. 이러한 정보들은 Job이 중단되었을 때 재시작을 하거나, 혹은 중복 실행을 방지하기 위한 기능들을 위해 저장된다.

예를 들어 "회원 포인트 정산"이라고 하는 배치 작업에 비유를 해보면, 
- "회원 포인트 정산" Job이 되고
- "회원 정보 읽기 → 포인트 계산 → DB 저장" 와 같은 세부 단계가 Step이 된다.

이때 Step은 크게 세 가지 단계로 구성된다. 보통 배치처리를 할 때 데이터를 읽어오고 읽어온 데이터에 재처리 후 쓰는 구조로 이루어져있다. 

조금 더 세부 구조에 대해서 자세하게 정리해본다. 


### Job 

![Job](https://docs.spring.io/spring-batch/reference/_images/job-stereotypes-parameters.png)

위 그림은 Job의 계층구조를 표현한 그림이다. 
**Job**은 **전체 배치 프로세스를 캡슐화한** 도메인을 의미한다. **논리적인 배치 처리 단위**인 셈이다. 비유하자면 객체를 만들기 위한 클래스-like에 비유해볼 수 있다. Job에는 어떤 Step들을 **어떤 순서로 실행할지가** 정의되어 있다.

```java
@Bean
public Job footballJob(JobRepository jobRepository) {
    return new JobBuilder("footballJob", jobRepository)
                     .start(playerLoad())
                     .next(gameLoad())
                     .next(playerSummarization())
                     .build();
}
```


**JobInstance**는 Job과 JobParameter의 조합으로 이루어진 실질적인 실행 단위가 된다. JobParameter는 Job 실행 시 입력되는 **외부 파라미터**이다. 예를 들어 날짜, 사용자 ID 등이 이에 해당된다.
동일한 Job이더라도, JobParameter가 다르다면 이는 다른 JobInstance로 식별된다. 예를 들면 "회원 포인트 정산Job" + "오늘날짜, parameter"의 조합이 유일한 JobInstance로 식별된다. 

**JobExecution**은 특정 JobInstance의 **실행 기록**을 의미한다. 실패/재시도할 때마다 새로운 JobExecution이 생성된다고 볼 수 있다. 상태: `STARTING`, `STARTED`, `FAILED`, `COMPLETED`, `STOPPED` 등



### Step

Step은 Job을 수행하기 위한 세부 단계, 작업 처리의 단위이다. 
주로 Chunk 기반과 Tasklet 기반인 2가지 종류의 Step으로 나뉜다.

#### Chunk-Step


#### Tasklet-Step
---
title: 20250211
description: Classful 주소 체계, 배열과 arrayList의 차이점
author: codongmin
date: 2025-02-11
tags: ["ip address", "array", "arrayList"]

---



# Classful 주소 체계 

클래스풀(Classful Addressing) 주소 체계는 IP 주소를 규격화된 크기별로 구분시키는 방식입니다. IP 주소를 클래스(A, B, C등) 별로 규격화시켜, 쉽게 식별할 수 있게하는 주소 체계입니다. IP주소에는 클래스 개념이 존재하고, 이 클래스 개념을 알아야 어디까지 네트워크 영역이고, 호스트 IP 영역인지 알 수 있습니다. 클래스는 하나의 IP 주소에서 네트워크 영역과 호스트 영역을 나누는 방법이자 약속.



> IPv4 주소는 4바이트(32비트)이며, 1바잍씩 끊어서 표기함. 이때 각 바이트를 옥텟이라고 부르며, 각 옥탯은 0부터 255까지 숫자를 표현할 수 있음(2^8)

- A클래스는 초기 비트가 0(2진수)으로 시작하는 1옥텟을 네트워크 주소로 사용하고 3옥텟을 호스트 주소로 사용하는 클래스. 호스트 주소의 0과 255는 특수한 용도(네트워크 식별, 브로드캐스트 주소)로 사용되므로 A클래스에는 0/0.0.0 2^7개의 네트워크 주소와 2^24- 2개의 호스트주소를 가질 수 있습니다.
  - 0xxx xxxx /. xxxx xxxx. xxxx xxxx. xxxx xxxx
- B클래스는 초기 비트가 10(2진수, 128~)으로 시작하는 2옥탯을 네트워크 주소로 사용하며, 2옥텟을 호스트 주소로 사용합니다. 따라서, B 클래스에서는 2^14개의 네트워크 주소와 2^16-2 개의 호스트 주소를 가질 수 있습니다.
  - 10xx xxxx . xxxx xxxx./ xxxx xxxx. xxxx xxxx
- C클래스에서는 초기 비트가 110(2진수, 192~)으로 시작하는 3옥텟을 네트워크 주소로 사용하며 1옥텟을 호스트 주소로 사용합니다. 따라서 C 클래스에서는 2^21개의 네트워크 주소와 2^8-2개의 호스트 주소를 가질 수 있습니다.
  - 110x xxxx . xxxx xxxx. xxxx xxxx./ xxxx xxxx

클래스풀 주소 체계는 클래스별로 네트워크 크기가 고정되어 있기 때문에 다수의 IP 주소가 낭비될 수 있다는 한계점이 존재합니다. 예를 들어 특정 조직에 컴퓨터가 255개라면 C클래스 주소를 사용하지 못하고 B 클래스를 사용해야하는데, 이러한 상황에서 IP주소의 낭비가 발생할 수 있습니다. B 클래스는 약 65,000개의 호스트를 지원하므로, 이 경우 대부분의 IP 주소가 낭비됩니다. 나머지는 유휴 IP. 이러한 문제를 해결하고, 더욱 유동적인 방식으로 네트워크를 구획할 수 있도록 클래스리스 주소 체계가 등장했습니다.

### 클래스리스 주소 체계

클래스리스 주소 체계는(Classless Addressing) 클래스가 아닌 서브넷 마스크를 이용해 네트워크 주소와 호스트 주소를 구분하는 IP 주소 체계입니다. 이때 서브넷 마스크는 네트워크 구분을 위한 비트열을 의미합니다. 해당 비트열에서 네트워크 주소는 연속된 1(2진수), 호스트 주소는 연속된 0(2진수)으로 표현합니다. 특정 IP 주소와 서브넷마스크에 비트 연산을 수행하면, 네트워크 주소를 알아낼 수 있습니다. 예를 들어, 서브넷 마스크가 255.255.255.0, IP 주소가 168.168.168.168인 경우, 비트 연산을 수행하면 네트워크 주소인 168.168.168.0 를 알아낼 수 있습니다. 이 경우 1옥텟을 호스트 주소로 사용할 수 있습니다.

서브넷 마스크를 표기할 때는 CIDR(Classless Inter Domain Routing Notation) 표기법을 사용할 수 있는데, `IP 주소/서브넷 마스크 비트열의 1의 수` 형식으로 표현함. IP 주소가 168.168.168.168이며, 서브넷 마스크가 255.255.255.0인 경우에는 168.168.168.168/24

- 1111 1111. 1111 1111. 1111 1111. 0000 0000 → 24개





# 배열과 ArrayList의 차이

1. 할당된 공간을 변경할 수 있느냐 없느냐.

배열은 선언시 크기가 고정되며 이후 변경이 불가능함. 추후에 배열의 크기를 동적으로 변경할 수 없음. 반면에 ArrayList의 경우에는 배열의 크기를 동적으로 할당이 가능함. 배열의 크기를 늘리는 것은 아니 내부적으로 배열을 재생성하여 복제하는 방식으로 크기를 확장함. 배열의 공간과 데이터 양이 동일해질 경우 설정되어있는 기준에 따라 재설정된 용량으로 배열을 생성하고, 새로운 배열로 기존 배열을 복사하는 과정이 수행된다. (1.5배 정도)

만일 데이터의 수가 고정되어있고 미리 알 수 있다면 초기값을 설정해주는 것이 불필요한 동적 크기 조정을 막아 성능 상 이점이 있을 수 있음.

1. 데이터 유형

두 자료구조 모두 동일한 타입에 데이터를 담을 수 있다는 점은 같음. 하지만 ArrayList는 참조자료형만 저장이 가능함. 기본자료형을 사용하고 싶을 경우 래퍼 클래스 사용이 필요함.
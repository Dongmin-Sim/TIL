---
title: 20250122
description: 이진탐색
author: codongmin
date: 2025-01-22
tags: ["refactoring", "asynchronous", "git", "record", "learning-test", "law-of-demeter"]


---



# 두 시스템간 비동기 연동 방식의 종류

분리된 두 시스템 간의 비동기 연동하는 방식은 시스템 간의 결합도를 낮출 수 있으면서, 호출된 시스템의 응답을 (비동기) 기다리지 않으므로 사용자의 요청에 빨리 응답할 수 있는 부분이 존재. 

이러한 비동기 연동 방식에는 다음과 같은 방식들이 존재함. 

1. 메시징 시스템 활용 
2. 데이터베이스 활용
3. 파일-배치 활용 
4. CDC 활용 



**메시징 시스템**은 두 시스템 사이에 메시징 시스템을 두어, A 시스템에서 메시지를 메시징 시스템으로 보내고, 시스템 B에서는 메시징 시스템으로부터 메시지를 수신 & 처리하는 방식으로 구성. 메시징 시스템에는 kafka, rabbitMQ 와 같은 메시징 시스템들이 활용됨. 

해당 방식은 처리량이 높은 것이 장점이지만, 메시지의 유실, 메시지 소비 순서, 트랜잭션 등 고려해야할 사항들이 존재함. 

만일 메시지가 유실이 되었다면 어떻게 처리할 것인지? 다시 재전송할지?, 혹은 A 시스템에서 보낸 메시지들의 순서를 보장할 수 있을지, (메시징 시스템들이 수평적으로 확장되어있는 구조에서는 확실하게 보장할 수 없기도 하다고 함.) 와 같은 여러 예기치 못한 상황들에 대한 대처 처리방식을 필요로 함. 

트랜잭션의 경우에는 애플리케이션에서 데이터를 DB로 저장하고 메시지를 발송하는 로직이 있다고 했을때, 두 작업을 어떻게 원자적으로 처리할 수 있을지 고민해야함. 만약 메시지를 발송한 이후에 데이터베이스에서 롤백이 일어났다면?



**데이터베이스 활용방식**은 전통적인 방식으로 시스템 A에서 데이터베이스로 필요한 메시지 레코드들을 추가하는 방식으로 이루어짐. 이때, 별도의 연동 시스템이 DB를 주기적으로 확인하면서 B 시스템으로 메시지를 전파하는 방식. 

이 방식의 경우에는 트랜잭션을 보장할 수 있다는 장점과 메시지 유실 걱정이 없다는 것이 장점. 

고려해야할 점으로는 보내려는 메시지의 형식을 데이터베이스 스키마로 지정해주어야하기 때문에 보다 유연하지 않고, 데이터의 규모가 커질 경우 데이터베이스에 가해지는 부담도 고려를 해야함. 



**파일-배치** 방식은 주기적으로 데이터를 파일로 변환하고, FTP와 같은 프로토콜을 이용해 다른 시스템으로 보내는 배치성 작업에서 많이 사용되는 방법. 트랜잭션이 보장될 수 있는 구조이며, 파일을 보내는 주기에 대한 검토가 필요함. 

CDC(Change Data Capture) 활용방식은 데이터베이스의 로그기록을 관찰하고 있다가 변경 사항 발생시, 이를 포착하여 다른 시스템에 전파하는 방식임. 이 방식의 경우 애플리케이션 단의 메시징 처리 로직이 사라져 단순화할 수 있다는 장점이 존재하고, 이도 트랜잭션을 보장할 수 있음. 하지만 변경로그의 경우에는 변경의 이유를 담을 수 있는 메시지의 정보량이 깊지는 않다는 제약이 존재함. 



# 리팩토링 

리팩터링 2판 1장 실습을 하며 

리팩토링을 시작하기 전에는 꼭 테스트 코드가 필요하다. 테스트 코드 없이는 변경 후 올바르게 동작한다는 보장을 하기가 어렵다. 게다가 너무 많은 변경점이 있게될 경우 예외 발생시 어느 변경지점에서 에러가 발생하는지 디버깅하기가 무척 어려워진다. 

때문에 리팩토링전, 통과하는 자동화된 테스트를 만들고 확인 후 리팩토링을 해야한다. 그리고 작은 변경점에서도 컴파일-테스트-커밋 과정을 반복적으로 수행함으로 단계별로 개선된 & 동작하는 코드로 리팩토링할 수 있다. 

리팩토링의 가장 첫번째는 기능 별로 다른 부분을 함수로 추출하는 것. 하나의 함수의 여러가지 역할과 기능이 담겨있지 않도록 한다. 이를 위해 확연하게 다른 부분을 함수로 추출하는 작업을 선제적으로 진행한다. 이때는 함수로 추출될 영역에 유효한 범위를 갖는 변수들을 파악해서, 함수의 매개변수 & 반환값등을 설정할 수 있게 한다. 

함수를 추출한 이후에는 추출된 함수를 다시 검토하면서 적절한 이름의 메서드인지, 내부 변수들의 네이밍이 적절한지 검토한 후 테스트를 수행한다. 

이후에는 메서드 내에서 사용되는 임시 변수들을 리스링한다. 임시 변수들은 왠만하면 리팩토링을 통해 제거할 수 있도록 한다.  왜냐하면 다음과 같은 이유들에서 임시변수는 그리 좋지 못하다. 

1. 임시 변수는 특정 영역에서만 의미를 갖기 때문에 리팩터링 과정에서 함수로 추출시, 종종 매개변수로 전달되어야하는 경우가 존재함. 
2. 임시 변수가 여러 계산에 잘못 사용될 경우 버그 유발 가능성이 있음. 특히 가변적인 경우, 데이터의 흐름을 추적하기가 어려움. 

이러함 임시변수들은 대신 질의 함수로 변환할 수 있음. 질의 함수로 변환 시 보다 가독성 있고, 함수 추출시 전달되는 매개변수의 수를 줄일 수 있다는 장점을 가지고 있음. 

만일 반복문안에 서로 다른 역할을 하는 코드가 있다면 이를 두 개의 반복문으로 쪼갠 후 함수로 추출하는 방법을 사용할 수도 있다. 이 과정에서 반복문이 중복되므로 성능에 좋지 않은 영향을 줄 수 있지만, 이는 리팩터링 후에 성능을 개선하는 편을 추천한다고 책에서는 언급(설사 다시 돌아가더라도, 성능 개선 포인트가 더 명확해진다고 함)

리팩터링 1장을 실습하면서 느낀 점. 리팩토링을 진행하면서 테스트를 계속 돌리면서 최대한 작은 단위로 커밋을 반복하다보니, 한단계 한단계 쌓아가는 느낌과 코드가 동작함을 보장하면서 변화하고 있다는 사실이 흥미롭고 재밌었음. 리팩터링에서 책에서 언급하는 단계나 절차들이 반복되는 부분도 있어서 이 과정들은 꾸준히 연습해야 눈에 익고 감이 오겠다는 것을 느낌. 



# Record 클래스

Record 클래스는 Java14에서 처음 도입된 새로운 클래스 타입. 데이터의 불변 객체를 효율적으로 정의하기 위해 설계되었음. 기존의 일반 클래스에서 데이터 객체로 사용하기 위한 보일러 플레이트 코드들을 줄일 수 있음. 

record 클래스의 필드들은 자동으로 `private final` 으로 선언됨. 한번 초기화하면 변경할 수 없기 때문에 불변성을 보장할 수 있음. 

데이터의 불변성 객체를 정의하기 위해 설계된 목적에 따라 모든 필드들은 생성단계에서 반드시 초기화가 되어야함. 때문에 개발자에게 인자가 없는 기본생성자를 제공하지 않음. 대신 모든 필드를 인자로 받는 표준 생성자가 존재.  

커스텀 생성자를 만들더라도, 표준생성자를 호출해서 초기화를 진행해야함. 

다른 방식으로는 `static` 팩토리 메서드를 통해서 생성할 수 있음. 개인적으로는 이러한 방식과 잘 어울리는 듯함. 

```java
public record User(String name, int age) {
  public static User of(String name, int age) {
    return new User(name, age);
  }
}

---
User user = User.of("홍길동", 20);
```

Record 클래스는 일반 class 처럼 내부에 인스턴스 메서드를 정의해서 사용할 수도 있고, static 메서드를 선언할 수도 있음. 

다만 상속은 불가능하다는 특징이 존재.  Record는 암묵적으로 `final` 클래스, 컴파일시 붙여줌. 따라서 다른 클래스가 상속할 수 없음. 그리고 다른 클래스도 상속받을 수 없음. 왜냐하면 모든 클래스는 `java.lang.Record` 를 상속받기 때문임. 

앞서 불변 객체를 표현하기 적합하도록 설계되었기 때문에 주로 사용하는 `toString` `hashcode` `equals` `getter` 메서드들을 정의없이 호출할 수 있음(내부적으로 정의됨)



# Git 내부

git이 데이터를 어떻게 저장하는지 알면 git 사용시 이해가 잘 된다. git에는 4가지 오브젝트들이 존재. 

- Blob(파일로 봐도 무방), tree는 디렉토리를 추상화한 , commit, tag

Git 내부 오브젝트들은(커밋)은 DAG 자료구조를 가지고 있음.

- tag는 fixed pointer, branch 는 moved pointer

왜 같은 파일의 내용이 여러개일까?

- 델타모델과 스냅샷 모델

  - 델타 모델은 변화 값만 저장하는 방식

  - 스냅샷은 전체 카피 값을 뜸. 원본 + 변경점을 같이 카피 (깃은 스냅샷 채택)

다른 커밋이 같은 Blob을 참조하는 때는 어떤 경우일까?

- 변경사항이 없을때



git rebase 란



# 디미터의 법칙 

디미터의 법칙은 객체지향의 특징 중 캡슐화와 관련된 내용. 객체지향프로그래밍에서 "최소한의 지식 원칙"으로 알려진 설계 지침임. 

핵심 개념은 객체가 다른 객체의 내부 구조에 대해 지나치게 많이 알지 않도록 설계해야한 다는 원칙. 이를 통해서 객체간의 의존성을 최소화하고, 결합도를 낮출 수 있음. 

디미터의 법칙은 다음과 같은 규칙을 따를 수 있음. 

- 객체는 자기 자신 혹은 직접 연결된 객체와만 상호작용 할 수 있음.
- 메서드는 다음 객체들에게만 메시지를 보낼 수 있음.
  - 매개변수로 넘어온 객체, 
  - 매서느 내에서 생성된 지역 변수(객체),
  - 자신이 속한 클래스의 필드 객체, 
  - 자신이 속한 클래스의 컬렉션 요소 객체

만일 A 객체에서 B 객체 안에 있는 객체들의 메서드를 직접 사용한다면, B 객체안의 객체가 변경될때, B, A까지 줄줄히 변경되어야함. 때문에 이를 막고자 디미터의 법칙이라는 설계 원칙을 적용. 이는 점(.) 접근 연산자를 많이 사용하는 구조가 되기때문에 점 연산자를 너무 많이 사용할 경우 이 원칙을 되돌아볼 수 있음. 이때 내부 구조를 감춰 캡슐화를 강화해야 함. 

나는 이것을 남의 "집 냉장고를 열지마라"라고 이름 붙였음. 남의 집에 가서 냉장고를 마음대로 열어서 뭐있나 살펴보고 이런 것은 굉장히 무례한 행동이 될 수 있음. 디미터의 법칙도 객체간의 매너를 지키는 설계원칙으로 이해. 주요 원칙 중 "묻지 말고 시켜라"라는 원칙이 있음. 객체에게 데이터를 요청하지 말고, 원하는 작업을 수행한 결과를 요청하라는 것. 냉장고에서 먹고싶은 것을 주인에게 부탁하기(직접 열고 뒤적거리지 말고)

## 학습 테스트 

기능만 테스트하는 것이 아닌, 내가 잘 모르는 API 들, 패키지들을 단위테스트를 통해서 사용법을 익히는 테스트들을 학습 테스트라고 함. 



# JUnit


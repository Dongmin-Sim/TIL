---
title: SOLID 원칙
description: 객제지향 소프트웨어 설계 원칙.
author: codongmin
date: 2025-02-18T21:34:00
categories:
  - test
tags: ["mocking"]
image:
  path: /assets/img/thumbnail/_.png
  lqip:
  alt:
---
	oo
## 들어가며

SOLID 원칙이란 객체지향 프로그래밍을 설계할 때 소프트웨어의 유지보수성과 확장성을 높이기 위해 고려해야할 5가지 원칙을 의미. 이 원칙들은 소프트웨어의 응집도를 높이고, 결합도를 낮추는데 중요한 역할을 하는 원칙들. 각 원칙들의 앞글자만 따서 SOLID라고 불린다.


>“유지보수성이 높다”라는 말의 의미는 소프트웨어가 시간이 지나면서 발생하는 변경, 버그 수정, 기능 추가 등의 요구사항을 쉽게 관리하고 개선할 수 있다는 것을 의미.


## 응집도와 결합도

SOLID 원칙은 소프트웨어의 응집도와 결합도를 낮추는 큰 목적을 이루기 위한 구체적인 원칙들. 

응집도가 높은 모듈은 외부 의존성이 적고 독립적이기 때문에 변경사항이 다른 모듈에 미치는 영향을 최소화한다. 
또한 여러 역할이 아닌 특정 역할에 집중되어 있기 때문에 다른 곳에서 쉽게 재사용이 가능하다. 
단일 책임을 가질수록 테스트하기가 용이해진다.


## SRP

`책임과 역할`, `응집도`, 

S는 SRP의 줄임말로 Single Responsibility Principle, **단일 책임 원칙**을 말함. **어떤 모듈(클래스)를 변경하고자 할때 변경의 이유는 하나**이어야한다는 의미로 객체는 단 하나의 책임을 갖도록 해야한다는 것을 의미.

단일 책임 원칙을 잘 지키면 클래스가 **하나의 책임만**을 갖기 때문에 **내부의 기능적 관련성이 높이지게** 되고 그에 따라 응집도가 높아지게 뵌다. 응집도가 높아지면 각 기능이 독립적으로 관리되기 때문에 클래스 내부에서 변경이 일어나더라도 다른 기능에 미치는 영향을 최소화할 수 있음. 여러 기능들이 복합적으로 의존성을 갖지 않기 때문에 다른 모듈에서도 재사용하는 것이 쉬워진다. 테스트 측면에서도 장점이 존재한다. 단일 책임만 가지므로 테스트 복잡도가 낮아서 테스트하기가 용이해진다.

만일 단일 책임 원칙이 잘 지켜지지 않는다면, 한 클래스에 여러 책임이 섞이게 되어 한 기능의 변경이 다른 기능에 영향을 주기 쉬워 예상치 못한 에러 발생이나 코드의 복잡도를 높일 수 있음. 또한 테스트는 특정 기능을 잘 수행하는지 확인하기 위함이 목적인데 여러 기능이 섞여있다면 테스트를 위해서 준비해야하는 것들이 많아져 테스트가 어려워진다.

설계 시에는 하나의 클래스가 하나의 책임만을 갖도록 적절한 추상화를 하는 것이 필요하고, 
캡슐화와 추상화에 기반함.


> 모듈은 소프트웨어를 구성하는 단위로, 클래스, 함수, 독립적으로 컴파일 가능한 프로그램 등이 될 수 있다.


## OCP

`확장성`

O는 OCP의 줄임말로 Open/Closed Principle, **개방-폐쇄 원칙**을 말함. 이는 **소프트웨어 모듈은 확장에는 열려있고 변경에는 닫혀있어야 한다는 의미**로 새로운 모듈, 기능을 확장할 때는 기존의 코드의 변경을 야기해서는 안된다는 것을 의미합니다.

개방-폐쇄 원칙을 잘 지킬 경우 새로운 기능을 추가하더라도 기존의 코드에 영향을 주지 않고 확장이 가능해진다. 덕분에 코드의 안정성을 유지할 수 있다는 장점이 있다.

이를 잘 지키지 않는다면 새로운 기능이 추가될 때마다 기존의 코드의 변경이 동반된다는 의미로 코드의 안정성과 유지보수성이 떨어진다는 단점이 존재한다.

OCP를 적용하는 방법에는 대표적으로 
1. 추상화와 다형성을 활용하거나

개방 폐쇄 원칙을 지키는 대표적인 예시로는 인터페이스나, 추상 클래스를 활용해 새로운 기능을 추가할 때 기존 클래스의 코드를 변경하는 대신 인터페이스 구현 객체나, 서브클래스를 확장하므로써 OCP를 지킬 수 있다. JDBC의 예시가 그 예가 될 수 있다. 다양한 DB Driver가 추가되더라도 이를 사용하는 클라이언트 입장에서는 기존 코드의 변경이 필요하지 않다.

객체지향 특성 중 추상화와 다형성과 관련이 깊다.

## LSP

L은 LSP의 줄임말로 Liskov Substitution Principle, 리스코프 치환 원칙이다. 서브타입은 언제나 자신의 기반타입으로 변경할 수 있어야 함을 의미한다. 즉 상위타입의 규약, 행동을 하위타입에서 어겨서는 안된다는 의미.

이를 잘 지킬 경우 상속구조에서 상위 타입에서 정의한 행동을 하위 타입에서 동작함을 예측하기가 쉬워지지만, 이를 잘 지키지 않을 경우 상위 타입을 사용하는 코드에서 예상치 못한 오류가 발생될 수 있음.

LSP 원칙이 잘 적용된 예시가 자바의 컬렉션 프레임워크이다.

다형성의 일관성에 대한 내용으로 이해함.

## ISP

I는 ISP의 줄임말로 Interface Segregation Principle, 인터페이스 분리 원칙이다. 클래스는 자신이 사용하지 않는 메서드에 의존하지 않아야한다는 것을 의미한다. 즉, 꼭 필요한 역할만을 담은 작은 인터페이스를 제공해야한다는 의미다. 하나의 인터페이스가 하나의 목적만을 가져야한다는 것.

인터페이스 분리원칙을 잘 지킬 경우 이를 사용하는 클라이언트들의 관심사를 최소화할 수 있다. 각 클래스가 필요한 기능만 구현할 수 있어 역할과 책임이 명확해지고 특정 인터페이스의 기능을 변경하더라도 영향을 받는 클래스의 범위를 줄일 수 있다. → 유지보수성 높아짐.

이를 잘 지키지 않아 인터페이스가 커진다면(역할이 많다면) 클래스에게 필요하지 않은 기능까지 구현해야하므로 복잡해질 수 있고, 이를 사용하는 모든 클라이언트 객체들이 변경에 영향을 받게된다.

인터페이스를 통한 추상화와 밀접

## DIP

`유지보수성`

D는 DIP의 줄임말로 Dependency Inversion Principle, 의존성 역전 원칙이다. 고수준 모듈은 저수준 모듈에 의존하지 않고 둘 다 추상화에 의존해야 한다는 것을 의미한다. 즉, 잘 변하지 않는 것에 의존하므로 변경의 영향을 줄이는 것을 의미.

의존성 역전 원칙을 잘 지킬 경우 모듈 간의 결합도를 낮추어 유연한 설계가 가능하다.

이를 잘 지키지 않을 경우 저수준 모듈에 의존하게 되어 강하게 결합된다. 저수준 모듈이 변경될 때 고수준 모듈도 이에 따라 같이 변경이 되어야만 한다. 변경에 취약해질 수 있다. 또한 기능이 추가될 때도 고수준 모듈의 코드를 직접 변경하여야 하므로, OCP 원칙을 위반할 가능성도 높다.

인터페이스를 통한 추상화와 밀접

## 마무리하며
